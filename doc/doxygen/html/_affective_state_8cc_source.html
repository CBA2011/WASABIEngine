<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>WASABIEngine: AffectiveState.cc Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">WASABIEngine
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">The core library of WASABI Affect Simulation</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">AffectiveState.cc</div>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/********************************************************************************</span>
<a name="l00002"></a>00002 <span class="comment">**</span>
<a name="l00003"></a>00003 <span class="comment">** [W]ASABI [A]ffect [S]imulation [A]rchitecture for [B]elievable [I]nteractivity</span>
<a name="l00004"></a>00004 <span class="comment">**</span>
<a name="l00005"></a>00005 <span class="comment">** Copyright (C) 2011 Christian Becker-Asano.</span>
<a name="l00006"></a>00006 <span class="comment">** All rights reserved.</span>
<a name="l00007"></a>00007 <span class="comment">** Contact: Christian Becker-Asano (christian@becker-asano.de)</span>
<a name="l00008"></a>00008 <span class="comment">**</span>
<a name="l00009"></a>00009 <span class="comment">** This file is part of the WASABIEngine library.</span>
<a name="l00010"></a>00010 <span class="comment">**</span>
<a name="l00011"></a>00011 <span class="comment">** The WASABIEngine library is free software: you can redistribute it and/or modify</span>
<a name="l00012"></a>00012 <span class="comment">** it under the terms of the GNU Lesser General Public License as published by</span>
<a name="l00013"></a>00013 <span class="comment">** the Free Software Foundation, either version 3 of the License, or</span>
<a name="l00014"></a>00014 <span class="comment">** (at your option) any later version.</span>
<a name="l00015"></a>00015 <span class="comment">**</span>
<a name="l00016"></a>00016 <span class="comment">** The WASABIEngine library is distributed in the hope that it will be useful,</span>
<a name="l00017"></a>00017 <span class="comment">** but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00018"></a>00018 <span class="comment">** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00019"></a>00019 <span class="comment">** GNU Lesser General Public License for more details.</span>
<a name="l00020"></a>00020 <span class="comment">**</span>
<a name="l00021"></a>00021 <span class="comment">** You should have received a copy of the GNU Lesser General Public License</span>
<a name="l00022"></a>00022 <span class="comment">** along with the WASABIEngine library.  If not, see &lt;http://www.gnu.org/licenses/&gt;</span>
<a name="l00023"></a>00023 <span class="comment">**</span>
<a name="l00024"></a>00024 <span class="comment">********************************************************************************/</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#include  &quot;AffectiveState.h&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include  &quot;EmotionDynamics.h&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00031"></a>00031 <span class="comment">//#define INFINITY numeric_limits&lt;double&gt;::infinity( );</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="keyword">using namespace </span>std;
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="keywordtype">int</span>
<a name="l00036"></a>00036 returnIndex(<span class="keywordtype">string</span> word, <span class="keyword">const</span> <span class="keywordtype">string</span> line)
<a name="l00037"></a>00037 {
<a name="l00038"></a>00038     string::size_type begIdx, endIdx;
<a name="l00039"></a>00039     <span class="keyword">const</span> <span class="keywordtype">string</span> delims(<span class="stringliteral">&quot; &quot;</span>);
<a name="l00040"></a>00040     <span class="keywordflow">if</span> (line.empty()) {
<a name="l00041"></a>00041         <span class="keywordflow">return</span> 0;
<a name="l00042"></a>00042     }
<a name="l00043"></a>00043     begIdx = line.find_first_not_of(delims);
<a name="l00044"></a>00044     <span class="comment">//cout &lt;&lt; &quot;line = \&quot;&quot; &lt;&lt; line &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;</span>
<a name="l00045"></a>00045     <span class="comment">//cout &lt;&lt; &quot;word = \&quot;&quot; &lt;&lt; word &lt;&lt; &quot;\&quot;&quot; &lt;&lt; endl;</span>
<a name="l00046"></a>00046     <span class="keywordtype">int</span> wordcount = 1;
<a name="l00047"></a>00047     <span class="keywordflow">while</span> (begIdx != string::npos) {
<a name="l00048"></a>00048         endIdx = line.find_first_of(delims, begIdx);
<a name="l00049"></a>00049         <span class="keywordflow">if</span> (endIdx == string::npos) {
<a name="l00050"></a>00050             endIdx = line.length();
<a name="l00051"></a>00051         }
<a name="l00052"></a>00052         <span class="comment">//cout &lt;&lt; &quot;\nbegIdx = &quot; &lt;&lt; begIdx &lt;&lt; &quot;, endIdx = &quot; &lt;&lt; endIdx &lt;&lt; endl;</span>
<a name="l00053"></a>00053         <span class="keywordtype">string</span> token = line.substr(begIdx, (endIdx - begIdx));
<a name="l00054"></a>00054         <span class="comment">//cout &lt;&lt; &quot;EmotionContainer::returnIndex: token (&quot; &lt;&lt; token &lt;&lt; &quot;) == word (&quot; &lt;&lt; word &lt;&lt; &quot;) ? &quot;;</span>
<a name="l00055"></a>00055         <span class="keywordflow">if</span> (word == token) {
<a name="l00056"></a>00056             <span class="comment">//cout &lt;&lt; &quot;--&gt; yes, returning &quot; &lt;&lt; wordcount &lt;&lt; endl;</span>
<a name="l00057"></a>00057             <span class="keywordflow">return</span> wordcount;
<a name="l00058"></a>00058         }
<a name="l00059"></a>00059         <span class="comment">//cout &lt;&lt; &quot;--&gt; no, searching on&quot; &lt;&lt; endl;</span>
<a name="l00060"></a>00060         wordcount++;
<a name="l00061"></a>00061         begIdx = line.find_first_not_of(delims, endIdx);
<a name="l00062"></a>00062     }
<a name="l00063"></a>00063     <span class="keywordflow">return</span> 0;
<a name="l00064"></a>00064 }
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 
<a name="l00068"></a><a class="code" href="class_affective_state.html#a65e6807f1091c79f44a84c95adb1b4fd">00068</a> <a class="code" href="class_affective_state.html#a65e6807f1091c79f44a84c95adb1b4fd" title="Default Constructor.">AffectiveState::AffectiveState</a>()
<a name="l00069"></a>00069 {
<a name="l00070"></a>00070     init();
<a name="l00071"></a>00071 }
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <span class="keywordtype">void</span>
<a name="l00074"></a>00074 AffectiveState::init() {
<a name="l00075"></a>00075     lifetime = -1.0;
<a name="l00076"></a>00076     standardLifetime = -1.0;
<a name="l00077"></a>00077     decayFunction = AffectiveState::NONE;
<a name="l00078"></a>00078     intensity = 0.0;
<a name="l00079"></a>00079     <span class="keywordtype">id</span> = -1;
<a name="l00080"></a>00080     type = <span class="stringliteral">&quot;undefined&quot;</span>;
<a name="l00081"></a>00081     decayParameter = 1.0;
<a name="l00082"></a>00082     emoCon = 0;
<a name="l00083"></a>00083     baseIntensity = 1.0;
<a name="l00084"></a>00084     cout &lt;&lt; <span class="stringliteral">&quot;AffectiveState::init()&quot;</span> &lt;&lt; endl;
<a name="l00085"></a>00085 }
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 AffectiveState::~AffectiveState()
<a name="l00088"></a>00088 {
<a name="l00089"></a>00089     <span class="comment">// nothing</span>
<a name="l00090"></a>00090 }
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 <a class="code" href="class_affective_state.html#a65e6807f1091c79f44a84c95adb1b4fd" title="Default Constructor.">AffectiveState::AffectiveState</a>(std::vector&lt;AffectPolygon*&gt; ap_vec) {
<a name="l00093"></a>00093     init();
<a name="l00094"></a>00094     addPolygon(ap_vec);
<a name="l00095"></a>00095 }
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <a class="code" href="class_affective_state.html#a65e6807f1091c79f44a84c95adb1b4fd" title="Default Constructor.">AffectiveState::AffectiveState</a>(<a class="code" href="class_affect_polygon.html">AffectPolygon</a>* ap) {
<a name="l00098"></a>00098     init();
<a name="l00099"></a>00099     vector&lt;AffectPolygon*&gt; ap_vec;
<a name="l00100"></a>00100     ap_vec.push_back(ap);
<a name="l00101"></a>00101     addPolygon(ap_vec);
<a name="l00102"></a>00102 }
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 <span class="keywordtype">bool</span>
<a name="l00105"></a><a class="code" href="class_affective_state.html#a3b824330921fc05fe7dd2f49eec150d2">00105</a> <a class="code" href="class_affective_state.html#ae03bf91dc1939016fcd45ceb60e7cbf5">AffectiveState::setLifetime</a>(<span class="keywordtype">double</span> newLifetime) {
<a name="l00106"></a>00106     std::cout &lt;&lt; <span class="stringliteral">&quot;AffectiveState::setLifetime: got lifetime &quot;</span> &lt;&lt; newLifetime &lt;&lt; <span class="stringliteral">&quot;!&quot;</span> &lt;&lt; std::endl;
<a name="l00107"></a>00107     <span class="keywordflow">if</span> (newLifetime &lt; 0 &amp;&amp; newLifetime != -1.0) {
<a name="l00108"></a>00108         cout &lt;&lt; <span class="stringliteral">&quot;AffectiveState::setLifetime: value invalid &quot;</span> &lt;&lt; newLifetime &lt;&lt; <span class="stringliteral">&quot;!&quot;</span> &lt;&lt; endl;
<a name="l00109"></a>00109         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00110"></a>00110     }
<a name="l00111"></a>00111     lifetime = newLifetime;
<a name="l00112"></a>00112     intensity = 1.0;
<a name="l00113"></a>00113     <span class="keywordflow">if</span> (emoCon) {
<a name="l00114"></a>00114         <span class="keywordflow">if</span> (decayFunction == LINEAR){
<a name="l00115"></a>00115             decayParameter = (emoCon-&gt;dt)/lifetime;
<a name="l00116"></a>00116             cout &lt;&lt; <span class="stringliteral">&quot;AffectiveState::setLifetime: decayParameter = &quot;</span> &lt;&lt; decayParameter &lt;&lt; <span class="stringliteral">&quot;!&quot;</span> &lt;&lt; endl;
<a name="l00117"></a>00117         }
<a name="l00118"></a>00118         <span class="keywordflow">if</span> (decayFunction == EXPONENTIAL) {
<a name="l00119"></a>00119             decayParameter = 1 - (decayParameter * emoCon-&gt;dt);
<a name="l00120"></a>00120         }
<a name="l00121"></a>00121     }
<a name="l00122"></a>00122     <span class="keywordflow">else</span> {
<a name="l00123"></a>00123         cout &lt;&lt; <span class="stringliteral">&quot;AffectiveState::setLifetime: WARNING decayParameter not changed!&quot;</span> &lt;&lt; endl;
<a name="l00124"></a>00124     }
<a name="l00125"></a>00125 
<a name="l00126"></a>00126     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00127"></a>00127 }
<a name="l00128"></a>00128 
<a name="l00129"></a>00129 <span class="keywordtype">bool</span>
<a name="l00130"></a>00130 AffectiveState::setStandardLifetime(<span class="keywordtype">double</span> newLifetime) {
<a name="l00131"></a>00131     <span class="keywordflow">if</span> (newLifetime &lt; 0 &amp;&amp; newLifetime != -1.0) {
<a name="l00132"></a>00132         cout &lt;&lt; <span class="stringliteral">&quot;AffectiveState::setStandardLifetime: value invalid &quot;</span> &lt;&lt; newLifetime &lt;&lt; <span class="stringliteral">&quot;!&quot;</span> &lt;&lt; endl;
<a name="l00133"></a>00133         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00134"></a>00134     }
<a name="l00135"></a>00135     standardLifetime = newLifetime;
<a name="l00136"></a>00136     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00137"></a>00137 }
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="keywordtype">bool</span>
<a name="l00140"></a>00140 AffectiveState::setBaseIntensity(<span class="keywordtype">double</span> newIntensity) {
<a name="l00141"></a>00141     <span class="keywordflow">if</span> (newIntensity &lt; 0 || newIntensity &gt; 1.0) {
<a name="l00142"></a>00142         cout &lt;&lt; <span class="stringliteral">&quot;AffectiveState::setIntensity: value invalid &quot;</span> &lt;&lt; newIntensity &lt;&lt; <span class="stringliteral">&quot;!&quot;</span> &lt;&lt; endl;
<a name="l00143"></a>00143         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00144"></a>00144     }
<a name="l00145"></a>00145     baseIntensity = newIntensity;
<a name="l00146"></a>00146     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00147"></a>00147 }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 <span class="keywordtype">void</span>
<a name="l00151"></a><a class="code" href="class_affective_state.html#ad0208fab4ea9bf577155c8aae932c96b">00151</a> <a class="code" href="class_affective_state.html#ad0208fab4ea9bf577155c8aae932c96b">AffectiveState::setDecayFunction</a>(<a class="code" href="class_affective_state.html#aa47963a65353591a1e2109987ef624a1">decayFunctionEnum</a> decayFunc, <span class="keywordtype">double</span> decayParam) {
<a name="l00152"></a>00152     cout &lt;&lt; <span class="stringliteral">&quot;function &quot;</span> &lt;&lt; decayFunc &lt;&lt; <span class="stringliteral">&quot;, param &quot;</span> &lt;&lt; decayParam &lt;&lt; endl;
<a name="l00153"></a>00153     decayFunction = decayFunc;
<a name="l00154"></a>00154     <span class="keywordflow">if</span> (decayParam &gt; 0.0){
<a name="l00155"></a>00155         decayParameter = decayParam;
<a name="l00156"></a>00156     }
<a name="l00157"></a>00157     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (decayFunction == LINEAR) {
<a name="l00158"></a>00158         decayParameter = 0.01;
<a name="l00159"></a>00159     }
<a name="l00160"></a>00160 }
<a name="l00161"></a>00161 
<a name="l00165"></a>00165 <span class="keywordtype">void</span>
<a name="l00166"></a><a class="code" href="class_affective_state.html#add666df993512c3af62ad1b6b00cab18">00166</a> <a class="code" href="class_affective_state.html#add666df993512c3af62ad1b6b00cab18">AffectiveState::updateLikelihood</a>() {
<a name="l00167"></a>00167     <span class="keywordflow">if</span> (emoCon) {
<a name="l00168"></a>00168         vector&lt;int&gt; PADValues;
<a name="l00169"></a>00169         PADValues.push_back(emoCon-&gt;pValue);
<a name="l00170"></a>00170         PADValues.push_back(emoCon-&gt;aValue);
<a name="l00171"></a>00171         PADValues.push_back(emoCon-&gt;dValue);
<a name="l00172"></a>00172         likelihoods = updateLikelihood(PADValues);
<a name="l00173"></a>00173         <span class="keywordflow">return</span>;
<a name="l00174"></a>00174     }
<a name="l00175"></a>00175     cout &lt;&lt; <span class="stringliteral">&quot;AffectiveState::updateLikelihood(): &quot;</span> &lt;&lt; type &lt;&lt; <span class="stringliteral">&quot;, no emoCon set! Please provide PAD values.&quot;</span> &lt;&lt; endl;
<a name="l00176"></a>00176     vector&lt;AffectVertex*&gt; v;
<a name="l00177"></a>00177     likelihoods = v;
<a name="l00178"></a>00178 }
<a name="l00179"></a>00179 
<a name="l00183"></a>00183 vector&lt;AffectVertex*&gt;
<a name="l00184"></a><a class="code" href="class_affective_state.html#a3e447cea61d9d9dc7b758a68a4e8e009">00184</a> <a class="code" href="class_affective_state.html#a3e447cea61d9d9dc7b758a68a4e8e009">AffectiveState::getLikelihood</a>() {
<a name="l00185"></a>00185     <span class="keywordflow">return</span> likelihoods;
<a name="l00186"></a>00186 }
<a name="l00187"></a>00187 
<a name="l00193"></a>00193 vector&lt;AffectVertex*&gt; <a class="code" href="class_affective_state.html#add666df993512c3af62ad1b6b00cab18">AffectiveState::updateLikelihood</a>(vector&lt;int&gt; PAD) {
<a name="l00194"></a>00194     vector&lt;AffectVertex*&gt; v;
<a name="l00195"></a>00195     <span class="keywordflow">if</span> (PAD.size() != 3) {
<a name="l00196"></a>00196         cout &lt;&lt; <span class="stringliteral">&quot;AffectiveState::getLikelihood: PAD.size() != 3, returning empty vector!&quot;</span> &lt;&lt; endl;
<a name="l00197"></a>00197         <span class="keywordflow">return</span> v;
<a name="l00198"></a>00198     }
<a name="l00199"></a>00199     vector&lt;AffectPolygon*&gt;::iterator iter_ap;
<a name="l00200"></a>00200     <span class="keywordtype">int</span> polycount = 0;
<a name="l00201"></a>00201     <span class="keywordflow">for</span> (iter_ap = polygons.begin(); iter_ap != polygons.end(); ++iter_ap) {
<a name="l00202"></a>00202         vector&lt;AffectVertex*&gt; verts = (*iter_ap)-&gt;vertices;
<a name="l00203"></a>00203         <span class="comment">// Do we have a single point or a complete vertex here?</span>
<a name="l00204"></a>00204         <span class="keywordflow">if</span> (verts.size() == 1) { <span class="comment">// i.e. a point</span>
<a name="l00205"></a>00205             polycount++;
<a name="l00206"></a>00206             <span class="keywordflow">if</span> (intensity &gt; 0.0) { <span class="comment">// Only if AffectiveState is not OFF</span>
<a name="l00207"></a>00207                 <a class="code" href="class_affect_vertex.html">AffectVertex</a>* vertex = verts[0];
<a name="l00208"></a>00208                 <span class="keywordtype">float</span> a = ((float) (PAD[0] - vertex-&gt;coords[0])) / 100;
<a name="l00209"></a>00209                 <span class="keywordtype">float</span> b = ((float) (PAD[1] - vertex-&gt;coords[1])) / 100;
<a name="l00210"></a>00210                 <span class="keywordtype">float</span> c = ((float) (PAD[2] - vertex-&gt;coords[2])) / 100;
<a name="l00211"></a>00211                 <span class="keywordtype">float</span> tempDistance = sqrt(pow(c, 2) + pow(a, 2) + pow(b, 2));
<a name="l00212"></a>00212                 <span class="keywordflow">if</span> (tempDistance &lt;= (*iter_ap)-&gt;min_distance) {
<a name="l00213"></a>00213                     <span class="keywordflow">if</span> (tempDistance &lt; (*iter_ap)-&gt;max_distance) {
<a name="l00214"></a>00214                         tempDistance = (*iter_ap)-&gt;max_distance;
<a name="l00215"></a>00215                     }
<a name="l00216"></a>00216                     <span class="keywordtype">float</span> activation = 1.0;
<a name="l00217"></a>00217                     <span class="keywordflow">if</span> ((*iter_ap)-&gt;min_distance &gt; (*iter_ap)-&gt;max_distance) {
<a name="l00218"></a>00218                         activation = 1 - (tempDistance
<a name="l00219"></a>00219                                           - (*iter_ap)-&gt;max_distance)
<a name="l00220"></a>00220                                 / ((*iter_ap)-&gt;min_distance
<a name="l00221"></a>00221                                    - (*iter_ap)-&gt;max_distance);
<a name="l00222"></a>00222                     }
<a name="l00223"></a>00223                     vertex-&gt;likelihood = activation * intensity; <span class="comment">// NOTE: we take the AffectiveState&#39;s intensity here!!!</span>
<a name="l00224"></a>00224                     <span class="keywordflow">if</span> (vertex-&gt;likelihood &lt; 0.001) {
<a name="l00225"></a>00225                         vertex-&gt;likelihood = 0.0;
<a name="l00226"></a>00226                     } <span class="keywordflow">else</span> {
<a name="l00227"></a>00227                         <span class="comment">//dump(cout);</span>
<a name="l00228"></a>00228                         v.push_back(vertex);
<a name="l00229"></a>00229                     }
<a name="l00230"></a>00230                 } <span class="comment">// end if (tempDistance ..)</span>
<a name="l00231"></a>00231                 <span class="keywordflow">else</span> {
<a name="l00232"></a>00232                     vertex-&gt;likelihood = 0.0;
<a name="l00233"></a>00233                 }
<a name="l00234"></a>00234             } <span class="comment">// end if (verts[0]-&gt;intensity ..)</span>
<a name="l00235"></a>00235         } <span class="comment">// end if (verts.size() ..)</span>
<a name="l00236"></a>00236         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (verts.size() == 2) { <span class="comment">// i.e. a line</span>
<a name="l00237"></a>00237             cout &lt;&lt; <span class="stringliteral">&quot;AffectiveState::getLikelihood: TODO line!&quot;</span> &lt;&lt; endl;
<a name="l00238"></a>00238             <span class="comment">// calculate the distance between point and line here</span>
<a name="l00239"></a>00239         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (verts.size() &gt; 2) { <span class="comment">// some polygon</span>
<a name="l00240"></a>00240             <span class="comment">//cout &lt;&lt; &quot;updateLikelihood for &quot; &lt;&lt; type &lt;&lt; endl;</span>
<a name="l00241"></a>00241             <span class="keywordflow">if</span> (verts[0]-&gt;intensity &gt; 0.0) { <span class="comment">// Only if Vertex is not OFF</span>
<a name="l00242"></a>00242                 <span class="keywordtype">float</span> polygon_likelihood = (*iter_ap)-&gt;getIntensity(PAD.at(0),
<a name="l00243"></a>00243                                                                     PAD.at(1), PAD.at(2));
<a name="l00244"></a>00244                 <span class="keywordflow">if</span> (polygon_likelihood &gt; 0.005) {
<a name="l00245"></a>00245                     <span class="comment">//cout &lt;&lt; &quot;AffectiveState::updateLikelihood: got likelihood &quot; &lt;&lt; polygon_likelihood</span>
<a name="l00246"></a>00246                     <span class="comment">//     &lt;&lt; &quot; for &quot; &lt;&lt; type &lt;&lt; endl;</span>
<a name="l00247"></a>00247                     polygon_likelihood *= getIntensity();
<a name="l00248"></a>00248                 } <span class="keywordflow">else</span> {
<a name="l00249"></a>00249                     polygon_likelihood = 0.0;
<a name="l00250"></a>00250                 }
<a name="l00251"></a>00251                 <span class="keywordflow">if</span> (polygon_likelihood &gt; 0.005) {
<a name="l00252"></a>00252                     vector&lt;AffectVertex*&gt;::iterator iter_verts;
<a name="l00253"></a>00253                     <span class="keywordflow">for</span> (iter_verts = verts.begin(); iter_verts != verts.end(); iter_verts++) {
<a name="l00254"></a>00254                         (*iter_verts)-&gt;likelihood = polygon_likelihood;
<a name="l00255"></a>00255                         v.push_back((*iter_verts));
<a name="l00256"></a>00256                     }
<a name="l00257"></a>00257                 }
<a name="l00258"></a>00258             }
<a name="l00259"></a>00259         }
<a name="l00260"></a>00260     } <span class="comment">// end for</span>
<a name="l00261"></a>00261     sort(v.begin(), v.end());
<a name="l00262"></a>00262     <span class="keywordflow">return</span> v;
<a name="l00263"></a>00263 }
<a name="l00264"></a>00264 
<a name="l00265"></a>00265 <span class="keywordtype">bool</span>
<a name="l00266"></a><a class="code" href="class_affective_state.html#af7ac4f21de22c0ab43e3889458c61ff2">00266</a> <a class="code" href="class_affective_state.html#af7ac4f21de22c0ab43e3889458c61ff2">AffectiveState::addPolygon</a>(std::vector&lt;AffectPolygon*&gt; data){
<a name="l00267"></a>00267     <span class="keywordflow">if</span> (data.empty()){
<a name="l00268"></a>00268         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00269"></a>00269     }
<a name="l00270"></a>00270 
<a name="l00271"></a>00271     vector&lt; AffectPolygon* &gt;::iterator iter_polys;
<a name="l00272"></a>00272     <span class="keywordflow">for</span>(iter_polys=data.begin(); iter_polys!=data.end(); iter_polys++) {
<a name="l00273"></a>00273         <span class="keywordflow">if</span> ((*iter_polys)-&gt;valid()){
<a name="l00274"></a>00274             polygons.push_back((*iter_polys));
<a name="l00275"></a>00275         }
<a name="l00276"></a>00276     }
<a name="l00277"></a>00277     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00278"></a>00278 }
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 <span class="keywordtype">bool</span>
<a name="l00281"></a>00281 <a class="code" href="class_affective_state.html#af7ac4f21de22c0ab43e3889458c61ff2">AffectiveState::addPolygon</a>(<a class="code" href="class_affect_polygon.html">AffectPolygon</a>* polygon){
<a name="l00282"></a>00282     <span class="keywordflow">if</span> (polygon == 0 || !(polygon-&gt;<a class="code" href="class_affect_polygon.html#a8483a6d1e2f22bd6d975aad7521c3761">valid</a>())) {
<a name="l00283"></a>00283         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00284"></a>00284     }
<a name="l00285"></a>00285 
<a name="l00286"></a>00286     vector&lt; AffectPolygon* &gt; data;
<a name="l00287"></a>00287     data.push_back(polygon);
<a name="l00288"></a>00288     <span class="keywordflow">return</span> addPolygon(data);
<a name="l00289"></a>00289 }
<a name="l00290"></a>00290 
<a name="l00291"></a>00291 <span class="keywordtype">void</span>
<a name="l00292"></a><a class="code" href="class_affective_state.html#a82b0f96a1494f5c58a6bec2840f3728a">00292</a> <a class="code" href="class_affective_state.html#a82b0f96a1494f5c58a6bec2840f3728a" title="Will update the intensity value according to the decay function und relative to the dt...">AffectiveState::update</a>(<span class="keywordtype">float</span> dt){
<a name="l00293"></a>00293     <span class="comment">//cout &lt;&lt; &quot;AffectiveState::update: &quot; &lt;&lt; type &lt;&lt; &quot; with dt &quot; &lt;&lt; dt &lt;&lt; &quot; now!&quot; &lt;&lt; endl;</span>
<a name="l00294"></a>00294     <span class="comment">//cout &lt;&lt; &quot;lifetime = &quot; &lt;&lt; lifetime &lt;&lt; endl;</span>
<a name="l00295"></a>00295     <span class="keywordflow">if</span> (lifetime &gt; 0.0){
<a name="l00296"></a>00296         lifetime -= dt;
<a name="l00297"></a>00297     }
<a name="l00298"></a>00298     <span class="keywordflow">switch</span> (decayFunction) {
<a name="l00299"></a>00299     <span class="keywordflow">case</span> NONE:
<a name="l00300"></a>00300         <span class="keywordflow">break</span>;
<a name="l00301"></a>00301     <span class="keywordflow">case</span> LINEAR:
<a name="l00302"></a>00302         intensity -= decayParameter;
<a name="l00303"></a>00303         <span class="comment">//cout &lt;&lt; &quot;intensity = &quot; &lt;&lt; intensity &lt;&lt; endl;</span>
<a name="l00304"></a>00304         <span class="keywordflow">break</span>;
<a name="l00305"></a>00305     <span class="keywordflow">case</span> EXPONENTIAL:
<a name="l00306"></a>00306         intensity *= decayParameter;
<a name="l00307"></a>00307         <span class="keywordflow">break</span>;
<a name="l00308"></a>00308     <span class="keywordflow">case</span> COSINE:
<a name="l00309"></a>00309         cout &lt;&lt; <span class="stringliteral">&quot;AffectiveState::update: COSINE TODO&quot;</span> &lt;&lt; endl;
<a name="l00310"></a>00310         <span class="keywordflow">break</span>;
<a name="l00311"></a>00311     <span class="keywordflow">default</span>:
<a name="l00312"></a>00312         cout &lt;&lt; <span class="stringliteral">&quot;AffectiveState::update: mode &quot;</span> &lt;&lt; decayFunction &lt;&lt; <span class="stringliteral">&quot; is unknown!&quot;</span> &lt;&lt; endl;
<a name="l00313"></a>00313     }
<a name="l00314"></a>00314     <span class="keywordflow">if</span> (lifetime == -1.0) {
<a name="l00315"></a>00315         intensity = baseIntensity;
<a name="l00316"></a>00316     }
<a name="l00317"></a>00317     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lifetime &lt; 0.01) {
<a name="l00318"></a>00318         intensity = 0.0;
<a name="l00319"></a>00319         lifetime = 0.0;
<a name="l00320"></a>00320     }
<a name="l00321"></a>00321     <span class="keywordflow">if</span> (intensity &lt; 0.01) {
<a name="l00322"></a>00322         intensity = baseIntensity;
<a name="l00323"></a>00323         lifetime = 0.0;
<a name="l00324"></a>00324     }
<a name="l00325"></a>00325 
<a name="l00326"></a>00326     <span class="comment">// We dont need to update the intensities of every Vertex here!</span>
<a name="l00327"></a>00327     <span class="comment">//   vector&lt;AffectPolygon*&gt;::iterator iter_poly = polygons.begin();</span>
<a name="l00328"></a>00328     <span class="comment">//   for (; iter_poly != polygons.end(); iter_poly++){</span>
<a name="l00329"></a>00329     <span class="comment">//     if ((*iter_poly)-&gt;vertices.size() == 1) { // i.e. a single point</span>
<a name="l00330"></a>00330     <span class="comment">//       (*iter_poly)-&gt;vertices.at(0)-&gt;intensity = intensity;</span>
<a name="l00331"></a>00331     <span class="comment">//     }</span>
<a name="l00332"></a>00332     <span class="comment">//   }</span>
<a name="l00333"></a>00333     <span class="comment">//cout &lt;&lt; &quot;AffectiveState::update: type &quot; &lt;&lt; type &lt;&lt; &quot; with intensity now &quot; &lt;&lt; intensity &lt;&lt; &quot;, lifetime now &quot; &lt;&lt; lifetime &lt;&lt; endl;</span>
<a name="l00334"></a>00334     <span class="comment">// at last we update the likelihoods</span>
<a name="l00335"></a>00335     updateLikelihood();
<a name="l00336"></a>00336 }
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="keywordtype">bool</span>
<a name="l00339"></a><a class="code" href="class_affective_state.html#a952cec059138bd392c5897a18ed3b6cd">00339</a> <a class="code" href="class_affective_state.html#a952cec059138bd392c5897a18ed3b6cd">AffectiveState::setIntensity</a>(<span class="keywordtype">double</span> newIntensity){
<a name="l00340"></a>00340     <span class="keywordflow">if</span> (newIntensity &gt; 1.0 || newIntensity &lt; 0.0){
<a name="l00341"></a>00341         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00342"></a>00342     }
<a name="l00343"></a>00343     intensity = newIntensity;
<a name="l00344"></a>00344     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00345"></a>00345 }
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 <span class="keywordtype">void</span>
<a name="l00348"></a><a class="code" href="class_affective_state.html#abe11a841bcd9979d183a946b476142d8">00348</a> <a class="code" href="class_affective_state.html#abe11a841bcd9979d183a946b476142d8" title="Dump to stream for debugging.">AffectiveState::dump</a>(ostream&amp; ostr)
<a name="l00349"></a>00349 {
<a name="l00350"></a>00350     <span class="keywordtype">int</span> poly_count = 0;
<a name="l00351"></a>00351     <span class="keywordtype">int</span> vertex_count = 0;
<a name="l00352"></a>00352     ostr &lt;&lt; <span class="stringliteral">&quot;#######################&quot;</span> &lt;&lt; endl
<a name="l00353"></a>00353          &lt;&lt; <span class="stringliteral">&quot;# AffectiveState \&quot;&quot;</span> &lt;&lt; type &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span>
<a name="l00354"></a>00354          &lt;&lt; <span class="stringliteral">&quot; has &quot;</span> &lt;&lt; polygons.size() &lt;&lt; <span class="stringliteral">&quot; polygon(s) &quot;</span> &lt;&lt; endl;
<a name="l00355"></a>00355     vector&lt; AffectPolygon* &gt;::iterator iter_polys;
<a name="l00356"></a>00356     <span class="keywordflow">for</span>(iter_polys=polygons.begin(); iter_polys!=polygons.end(); iter_polys++) {
<a name="l00357"></a>00357         <span class="keywordflow">if</span> ((*iter_polys)-&gt;valid()){
<a name="l00358"></a>00358             poly_count++;
<a name="l00359"></a>00359             vertex_count = 0;
<a name="l00360"></a>00360             ostr &lt;&lt; <span class="stringliteral">&quot;# - polygon (&quot;</span> &lt;&lt; poly_count &lt;&lt; <span class="stringliteral">&quot;) number of vertices &quot;</span>
<a name="l00361"></a>00361                  &lt;&lt; ((*iter_polys)-&gt;vertices).size() &lt;&lt; endl;
<a name="l00362"></a>00362             vector&lt; AffectVertex* &gt;::iterator iter_verts;
<a name="l00363"></a>00363             <span class="keywordflow">for</span>(iter_verts=(*iter_polys)-&gt;vertices.begin(); iter_verts!=(*iter_polys)-&gt;vertices.end(); iter_verts++) {
<a name="l00364"></a>00364                 vertex_count++;
<a name="l00365"></a>00365                 ostr &lt;&lt; <span class="stringliteral">&quot;# - - vertex (&quot;</span> &lt;&lt; vertex_count &lt;&lt; <span class="stringliteral">&quot;) coords = (&quot;</span>
<a name="l00366"></a>00366                      &lt;&lt; (*iter_verts)-&gt;coords[0] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>
<a name="l00367"></a>00367                      &lt;&lt; (*iter_verts)-&gt;coords[1] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>
<a name="l00368"></a>00368                      &lt;&lt; (*iter_verts)-&gt;coords[2] &lt;&lt; <span class="stringliteral">&quot;), &quot;</span>
<a name="l00369"></a>00369                      &lt;&lt; <span class="stringliteral">&quot;likelihood = &quot;</span> &lt;&lt; (*iter_verts)-&gt;likelihood &lt;&lt; endl;
<a name="l00370"></a>00370             }
<a name="l00371"></a>00371         }
<a name="l00372"></a>00372     }
<a name="l00373"></a>00373     ostr &lt;&lt; <span class="stringliteral">&quot;#######################&quot;</span> &lt;&lt; endl;
<a name="l00374"></a>00374 }
<a name="l00375"></a>00375 
<a name="l00376"></a>00376 <span class="keywordtype">bool</span>
<a name="l00377"></a><a class="code" href="class_affective_state.html#a913bce75bbf5bb870207e69fefb5efef">00377</a> <a class="code" href="class_affective_state.html#a913bce75bbf5bb870207e69fefb5efef">AffectiveState::setLikelihood</a>(<span class="keywordtype">float</span> newLikelihood)
<a name="l00378"></a>00378 {
<a name="l00379"></a>00379     <span class="keywordflow">if</span> (!emoCon || emoCon-&gt;isActive()) {
<a name="l00380"></a>00380         cout &lt;&lt; <span class="stringliteral">&quot;AffectiveState::setLikelihood: no emoCon or emoCon is active!&quot;</span> &lt;&lt; endl;
<a name="l00381"></a>00381         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00382"></a>00382     }
<a name="l00383"></a>00383     vector&lt;AffectPolygon*&gt;::iterator iter_ap;
<a name="l00384"></a>00384     <span class="keywordflow">for</span> (iter_ap = polygons.begin(); iter_ap != polygons.end(); ++iter_ap){
<a name="l00385"></a>00385         vector&lt;AffectVertex*&gt; verts = (*iter_ap)-&gt;vertices;
<a name="l00386"></a>00386         vector&lt;AffectVertex*&gt;::iterator iter_av;
<a name="l00387"></a>00387         <span class="keywordflow">for</span> (iter_av = verts.begin(); iter_av != verts.end(); ++iter_av){
<a name="l00388"></a>00388             (*iter_av)-&gt;likelihood = newLikelihood;
<a name="l00389"></a>00389         }
<a name="l00390"></a>00390     }
<a name="l00391"></a>00391     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00392"></a>00392 }
<a name="l00393"></a>00393 
<a name="l00394"></a>00394 
<a name="l00395"></a>00395 
<a name="l00396"></a>00396 AffectVertex::AffectVertex()
<a name="l00397"></a>00397 {
<a name="l00398"></a>00398     init();
<a name="l00399"></a>00399 }
<a name="l00400"></a>00400 
<a name="l00401"></a>00401 AffectVertex::AffectVertex(<span class="keywordtype">int</span> data[3])
<a name="l00402"></a>00402 {
<a name="l00403"></a>00403     init();
<a name="l00404"></a>00404     coords[0] = data[0];
<a name="l00405"></a>00405     coords[1] = data[1];
<a name="l00406"></a>00406     coords[2] = data[2];
<a name="l00407"></a>00407 }
<a name="l00408"></a>00408 
<a name="l00409"></a>00409 AffectVertex::AffectVertex(<span class="keywordtype">int</span> data[3], <span class="keywordtype">double</span> intens)
<a name="l00410"></a>00410 {
<a name="l00411"></a>00411     init();
<a name="l00412"></a>00412     coords[0] = data[0];
<a name="l00413"></a>00413     coords[1] = data[1];
<a name="l00414"></a>00414     coords[2] = data[2];
<a name="l00415"></a>00415     <span class="keywordflow">if</span> (intens &gt;= 0.0 &amp;&amp; intens &lt;= 1.0) {
<a name="l00416"></a>00416         intensity = intens;
<a name="l00417"></a>00417     }
<a name="l00418"></a>00418     <span class="keywordflow">else</span> {
<a name="l00419"></a>00419         cout &lt;&lt; <span class="stringliteral">&quot;AffectVertex::AffectVertex: Given intensity value &quot;</span>
<a name="l00420"></a>00420              &lt;&lt; intens &lt;&lt; <span class="stringliteral">&quot; not within [0.0, 1.0] --&gt; setting 1.0.&quot;</span> &lt;&lt; endl;
<a name="l00421"></a>00421         intensity = 1.0;
<a name="l00422"></a>00422     }
<a name="l00423"></a>00423 }
<a name="l00424"></a>00424 
<a name="l00425"></a>00425 <span class="keywordtype">void</span>
<a name="l00426"></a>00426 AffectVertex::init(){
<a name="l00427"></a>00427     <span class="comment">// The following default value lets the plain vertex be invalid.</span>
<a name="l00428"></a>00428     coords[0] = coords[1] = coords[2] = -101;
<a name="l00429"></a>00429     intensity = 1.0;
<a name="l00430"></a>00430     likelihood = 0.0;
<a name="l00431"></a>00431 }
<a name="l00432"></a>00432 
<a name="l00433"></a>00433 <span class="keywordtype">bool</span>
<a name="l00434"></a>00434 AffectVertex::valid(){
<a name="l00435"></a>00435     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> index = 0; index &lt;= 2; index++){
<a name="l00436"></a>00436         <span class="keywordflow">if</span> (coords[index] &gt; 100 || coords[index] &lt; -100){
<a name="l00437"></a>00437             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00438"></a>00438         }
<a name="l00439"></a>00439     }
<a name="l00440"></a>00440     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00441"></a>00441 }
<a name="l00442"></a>00442 
<a name="l00443"></a>00443 AffectPolygon::AffectPolygon()
<a name="l00444"></a>00444 {
<a name="l00445"></a>00445     init();
<a name="l00446"></a>00446 }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448 AffectPolygon::AffectPolygon(vector&lt;AffectVertex*&gt; av_vec, <span class="keywordtype">string</span> glMode)
<a name="l00449"></a>00449 {
<a name="l00450"></a>00450     init(glMode);
<a name="l00451"></a>00451     addVertices(av_vec);
<a name="l00452"></a>00452     <span class="comment">//cout &lt;&lt; &quot;#######################&quot; &lt;&lt; endl;</span>
<a name="l00453"></a>00453 }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455 AffectPolygon::AffectPolygon(<a class="code" href="class_affect_vertex.html">AffectVertex</a>* av)
<a name="l00456"></a>00456 {
<a name="l00457"></a>00457     init();
<a name="l00458"></a>00458     vector&lt;AffectVertex*&gt; av_vec;
<a name="l00459"></a>00459     av_vec.push_back(av);
<a name="l00460"></a>00460     addVertices(av_vec);
<a name="l00461"></a>00461 }
<a name="l00462"></a>00462 
<a name="l00463"></a>00463 <span class="keywordtype">void</span>
<a name="l00464"></a>00464 AffectPolygon::init(<span class="keywordtype">string</span> gl_mode) {
<a name="l00465"></a>00465     min_distance = 0.64; <span class="comment">// same as outerRadius</span>
<a name="l00466"></a>00466     max_distance = 0.2; <span class="comment">// same as innerRadius</span>
<a name="l00467"></a>00467     glMode = gl_mode; <span class="comment">// Dont want to include OpenGL headers here</span>
<a name="l00468"></a>00468     minX = minY = 101; <span class="comment">// invalid value!</span>
<a name="l00469"></a>00469     maxX = maxY = -101;
<a name="l00470"></a>00470 }
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 <span class="keywordtype">void</span>
<a name="l00473"></a><a class="code" href="class_affect_polygon.html#a7af2c3c08a837bff793e6be83c81b81c">00473</a> <a class="code" href="class_affect_polygon.html#a7af2c3c08a837bff793e6be83c81b81c" title="To add vertices to the polygon.">AffectPolygon::addVertices</a>(vector&lt;AffectVertex*&gt; verts){
<a name="l00474"></a>00474     vector&lt; AffectVertex* &gt;::iterator iter_vertices;
<a name="l00475"></a>00475     <span class="keywordflow">for</span>(iter_vertices=verts.begin(); iter_vertices!=verts.end(); iter_vertices++) {
<a name="l00476"></a>00476         <span class="keywordflow">if</span> ((*iter_vertices)-&gt;valid()){
<a name="l00477"></a>00477             <span class="keywordflow">if</span> ((*iter_vertices)-&gt;coords[0] &lt; minX) {
<a name="l00478"></a>00478                 minX = (*iter_vertices)-&gt;coords[0];
<a name="l00479"></a>00479             }
<a name="l00480"></a>00480             <span class="keywordflow">if</span> ((*iter_vertices)-&gt;coords[0] &gt; maxX) {
<a name="l00481"></a>00481                 maxX = (*iter_vertices)-&gt;coords[0];
<a name="l00482"></a>00482             }
<a name="l00483"></a>00483             <span class="keywordflow">if</span> ((*iter_vertices)-&gt;coords[1] &lt; minY) {
<a name="l00484"></a>00484                 minY = (*iter_vertices)-&gt;coords[1];
<a name="l00485"></a>00485             }
<a name="l00486"></a>00486             <span class="keywordflow">if</span> ((*iter_vertices)-&gt;coords[1] &gt; maxY) {
<a name="l00487"></a>00487                 maxY = (*iter_vertices)-&gt;coords[1];
<a name="l00488"></a>00488             }
<a name="l00489"></a>00489             vertices.push_back((*iter_vertices));
<a name="l00490"></a>00490         }
<a name="l00491"></a>00491     }
<a name="l00492"></a>00492 }
<a name="l00493"></a>00493 
<a name="l00494"></a>00494 
<a name="l00495"></a>00495 <span class="keywordtype">bool</span>
<a name="l00496"></a><a class="code" href="class_affect_polygon.html#a8483a6d1e2f22bd6d975aad7521c3761">00496</a> <a class="code" href="class_affect_polygon.html#a8483a6d1e2f22bd6d975aad7521c3761">AffectPolygon::valid</a>(){
<a name="l00497"></a>00497     <span class="keywordflow">if</span> (vertices.empty()){
<a name="l00498"></a>00498         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00499"></a>00499     }
<a name="l00500"></a>00500     vector&lt; AffectVertex* &gt;::iterator iter_vertices;
<a name="l00501"></a>00501     <span class="keywordtype">int</span> dominance = -101;
<a name="l00502"></a>00502     <span class="keywordflow">for</span>(iter_vertices=vertices.begin(); iter_vertices!=vertices.end(); iter_vertices++) {
<a name="l00503"></a>00503         <span class="keywordflow">if</span> ((*iter_vertices)-&gt;valid()){
<a name="l00504"></a>00504             <span class="keywordflow">if</span> (dominance == -101) {
<a name="l00505"></a>00505                 dominance = (*iter_vertices)-&gt;coords[2];
<a name="l00506"></a>00506             }
<a name="l00507"></a>00507             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dominance != (*iter_vertices)-&gt;coords[2]) {
<a name="l00508"></a>00508                 cout &lt;&lt; <span class="stringliteral">&quot;AffectPolygon::valid(): &quot;</span> &lt;&lt; dominance &lt;&lt; <span class="stringliteral">&quot; != &quot;</span> &lt;&lt; (*iter_vertices)-&gt;coords[2] &lt;&lt; <span class="stringliteral">&quot; returning false!&quot;</span> &lt;&lt; endl;
<a name="l00509"></a>00509                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00510"></a>00510             }
<a name="l00511"></a>00511         }
<a name="l00512"></a>00512         <span class="keywordflow">else</span> {
<a name="l00513"></a>00513             cout &lt;&lt; <span class="stringliteral">&quot;AffectPolygon::valid(): vertex invalid, returning false!&quot;</span> &lt;&lt; endl;
<a name="l00514"></a>00514             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00515"></a>00515         }
<a name="l00516"></a>00516     }
<a name="l00517"></a>00517     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00518"></a>00518 }
<a name="l00519"></a>00519 
<a name="l00520"></a>00520 <span class="keywordtype">float</span>
<a name="l00521"></a>00521 AffectPolygon::getIntensity(<span class="keywordtype">int</span> p, <span class="keywordtype">int</span> a, <span class="keywordtype">int</span> d){
<a name="l00522"></a>00522     <span class="keywordflow">if</span> (minX &lt; -100 || minY &lt; -100 || maxX &gt; 100 || maxY &gt; 100 || vertices.empty()){
<a name="l00523"></a>00523         cout &lt;&lt; <span class="stringliteral">&quot;AffectPolygon::getIntensity: no valid min/max values!&quot;</span> &lt;&lt; endl;
<a name="l00524"></a>00524         <span class="keywordflow">return</span> 0.0;
<a name="l00525"></a>00525     }
<a name="l00526"></a>00526     <span class="keywordflow">if</span> (glMode != <span class="stringliteral">&quot;QUAD&quot;</span>){
<a name="l00527"></a>00527         cout  &lt;&lt; <span class="stringliteral">&quot;AffectPolygon::getIntensity: only QUAD supported so far!&quot;</span> &lt;&lt; endl;
<a name="l00528"></a>00528         <span class="keywordflow">return</span> 0.0;
<a name="l00529"></a>00529     }
<a name="l00530"></a>00530     <span class="keywordtype">float</span> returnValue = 0.0;
<a name="l00531"></a>00531     <span class="comment">//cout &lt;&lt; &quot;AffectPolygon::getIntensity: (p, a, d) = (&quot; &lt;&lt; p &lt;&lt; &quot;, &quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; d &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span>
<a name="l00532"></a>00532     <span class="keywordflow">if</span> (p &gt;= minX &amp;&amp; p &lt;= maxX &amp;&amp; a &gt;= minY &amp;&amp; a &lt;= maxY) {
<a name="l00533"></a>00533         <span class="keywordtype">int</span>* coords1 = vertices.at(0)-&gt;coords;
<a name="l00534"></a>00534         <span class="keywordtype">int</span>* coords2 = vertices.at(1)-&gt;coords;
<a name="l00535"></a>00535         <span class="keywordtype">int</span>* coords3 = vertices.at(2)-&gt;coords;
<a name="l00536"></a>00536         <span class="keywordtype">int</span>* coords4 = vertices.at(3)-&gt;coords;
<a name="l00537"></a>00537         <span class="keywordtype">int</span>* co[4];
<a name="l00538"></a>00538         co[0] = coords1;
<a name="l00539"></a>00539         co[1] = coords2;
<a name="l00540"></a>00540         co[2] = coords3;
<a name="l00541"></a>00541         co[3] = coords4;
<a name="l00542"></a>00542         <span class="comment">//cout &lt;&lt; &quot;vertex1: (&quot; &lt;&lt; coords1[0] &lt;&lt; &quot;, &quot; &lt;&lt; coords1[1] &lt;&lt; &quot;, &quot; &lt;&lt; coords1[2] &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span>
<a name="l00543"></a>00543         <span class="comment">//cout &lt;&lt; &quot;vertex2: (&quot; &lt;&lt; coords2[0] &lt;&lt; &quot;, &quot; &lt;&lt; coords2[1] &lt;&lt; &quot;, &quot; &lt;&lt; coords2[2] &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span>
<a name="l00544"></a>00544         <span class="keywordtype">float</span> m[4] = {0.0, 0.0, 0.0, 0.0};
<a name="l00545"></a>00545         <span class="keywordtype">int</span> x[4];
<a name="l00546"></a>00546         <span class="keywordtype">int</span> y[4];
<a name="l00547"></a>00547         <span class="keywordtype">float</span> b[4];
<a name="l00548"></a>00548         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt;= 3; i++) {
<a name="l00549"></a>00549             <span class="comment">//cout &lt;&lt; &quot;\ni = &quot; &lt;&lt; i &lt;&lt; endl;</span>
<a name="l00550"></a>00550             <span class="keywordtype">int</span> alpha = i;
<a name="l00551"></a>00551             <span class="keywordtype">int</span> beta = (alpha + 1) % 4;
<a name="l00552"></a>00552             <span class="keywordflow">if</span> (co[alpha][2] != d) {
<a name="l00553"></a>00553                 <span class="comment">//cout &lt;&lt; &quot;AffectPolygon::getIntensity: invalid dominance value &quot; &lt;&lt; d &lt;&lt; &quot;!&quot; &lt;&lt; endl;</span>
<a name="l00554"></a>00554                 <span class="keywordflow">return</span> 0.0;
<a name="l00555"></a>00555             }
<a name="l00556"></a>00556             y[alpha] = co[alpha][0];
<a name="l00557"></a>00557             b[alpha] = 0;
<a name="l00558"></a>00558             <span class="comment">//cout &lt;&lt; &quot;(&quot; &lt;&lt; co[alpha][0] &lt;&lt; &quot;, &quot; &lt;&lt; co[alpha][1] &lt;&lt; &quot;) --- (&quot; &lt;&lt; co[beta][0] &lt;&lt; &quot;, &quot; &lt;&lt; co[beta][1] &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span>
<a name="l00559"></a>00559             <span class="comment">// y = m * x + b</span>
<a name="l00560"></a>00560             <span class="comment">// m = (beta(y) - alpha(y)) / (beta(x) - alpha(x))</span>
<a name="l00561"></a>00561             <span class="comment">// b = alpha(y) - m * alpha(x)</span>
<a name="l00562"></a>00562             <span class="keywordflow">if</span> (co[alpha][0] != co[beta][0]) {
<a name="l00563"></a>00563                 m[alpha] = (float)(co[beta][1] - co[alpha][1]) / (float)(co[beta][0] - co[alpha][0]);
<a name="l00564"></a>00564                 b[alpha] = co[alpha][1] - m[alpha] * co[alpha][0];
<a name="l00565"></a>00565                 <span class="comment">//cout &lt;&lt; &quot;m = &quot; &lt;&lt; m[alpha] &lt;&lt; &quot;, b = &quot; &lt;&lt; b[alpha] &lt;&lt; endl;</span>
<a name="l00566"></a>00566                 y[alpha] = (int)floor( ((m[alpha] * (<span class="keywordtype">float</span>)p) + b[alpha]) + 0.5);
<a name="l00567"></a>00567             }
<a name="l00568"></a>00568             <span class="keywordflow">else</span> {
<a name="l00569"></a>00569                 m[alpha] = INFINITY; <span class="comment">// infinte</span>
<a name="l00570"></a>00570                 y[alpha] = co[alpha][0];
<a name="l00571"></a>00571                 x[alpha] = p; <span class="comment">// instead of infinity</span>
<a name="l00572"></a>00572                 b[alpha] = INFINITY;
<a name="l00573"></a>00573             }
<a name="l00574"></a>00574             <span class="comment">//cout &lt;&lt; &quot; (p,y[&quot; &lt;&lt; alpha &lt;&lt; &quot;]) = (&quot; &lt;&lt; p &lt;&lt; &quot;,&quot; &lt;&lt; y[alpha] &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span>
<a name="l00575"></a>00575         }
<a name="l00576"></a>00576         <span class="comment">// does the point lie within the polygon?</span>
<a name="l00577"></a>00577         <span class="comment">// x = (y - b) / m</span>
<a name="l00578"></a>00578         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> index_i = 0; index_i &lt; 4; index_i++) {
<a name="l00579"></a>00579             <span class="keywordflow">if</span> (x[index_i] != p) {
<a name="l00580"></a>00580                 <span class="keywordflow">if</span> (m[index_i] != 0){
<a name="l00581"></a>00581                     x[index_i] = (a - b[index_i]) / m[index_i];
<a name="l00582"></a>00582                 }
<a name="l00583"></a>00583                 <span class="keywordflow">else</span> {
<a name="l00584"></a>00584                     x[index_i] = p; <span class="comment">// instead of infinity</span>
<a name="l00585"></a>00585                 }
<a name="l00586"></a>00586                 <span class="comment">//cout &lt;&lt; &quot;x[&quot; &lt;&lt; index_i &lt;&lt; &quot;] = (&quot; &lt;&lt; a &lt;&lt; &quot; - &quot; &lt;&lt; b[index_i] &lt;&lt; &quot;) / &quot; &lt;&lt; m[index_i] &lt;&lt; &quot; = &quot; &lt;&lt; x[index_i] &lt;&lt; endl;</span>
<a name="l00587"></a>00587             }
<a name="l00588"></a>00588             <span class="comment">//cout &lt;&lt; &quot; (a,x[&quot; &lt;&lt; index_i &lt;&lt; &quot;]) = (&quot; &lt;&lt; a &lt;&lt; &quot;,&quot; &lt;&lt; x[index_i] &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span>
<a name="l00589"></a>00589         }
<a name="l00590"></a>00590         <span class="comment">//cout &lt;&lt; &quot;(x0, y0) = (&quot; &lt;&lt; x[0] &lt;&lt; &quot;, &quot; &lt;&lt; y[0] &lt;&lt; &quot;), x3 = &quot; &lt;&lt; x[3] &lt;&lt; endl;</span>
<a name="l00591"></a>00591         <span class="keywordflow">if</span> (a &lt;= y[0] &amp;&amp; p &lt;= x[1] &amp;&amp; a &gt;= y[2] &amp;&amp; p &gt;= x[3]) {
<a name="l00592"></a>00592             vector&lt;float&gt; tempVec1, tempVec2;
<a name="l00593"></a>00593             <span class="keywordtype">int</span> xy[2];
<a name="l00594"></a>00594             xy[0] = p;
<a name="l00595"></a>00595             xy[1] = a;
<a name="l00596"></a>00596             <span class="comment">//cout &lt;&lt; &quot;AffectPolygon::getIntensity: on polygon!&quot; &lt;&lt; endl;</span>
<a name="l00597"></a>00597             <span class="keywordflow">if</span> (a &lt;= max(co[0][1], co[1][1]) &amp;&amp; a &gt; min(co[0][1], co[1][1])) { <span class="comment">//</span>
<a name="l00598"></a>00598                 <span class="comment">//cout &lt;&lt; &quot;crossing line 0&quot; &lt;&lt; endl;</span>
<a name="l00599"></a>00599                 <span class="keywordflow">if</span> (tempVec1.empty()) {
<a name="l00600"></a>00600                     tempVec1 = linearInterpolation(const_cast &lt;AffectVertex&amp;&gt; (*vertices.at(0)), const_cast &lt;AffectVertex&amp;&gt; (*vertices.at(1)), xy);
<a name="l00601"></a>00601                 }
<a name="l00602"></a>00602                 <span class="keywordflow">else</span> {
<a name="l00603"></a>00603                     tempVec2 = linearInterpolation(const_cast &lt;AffectVertex&amp;&gt; (*vertices.at(0)), const_cast &lt;AffectVertex&amp;&gt; (*vertices.at(1)), xy);
<a name="l00604"></a>00604                 }
<a name="l00605"></a>00605             }
<a name="l00606"></a>00606             <span class="keywordflow">if</span> (a &lt;= max(co[1][1], co[2][1]) &amp;&amp; a &gt; min(co[1][1], co[2][1])) { <span class="comment">//</span>
<a name="l00607"></a>00607                 <span class="comment">//cout &lt;&lt; &quot;crossing line 1&quot; &lt;&lt; endl;</span>
<a name="l00608"></a>00608                 <span class="keywordflow">if</span> (tempVec1.empty()) {
<a name="l00609"></a>00609                     tempVec1 = linearInterpolation(const_cast &lt;AffectVertex&amp;&gt; (*vertices.at(1)), const_cast &lt;AffectVertex&amp;&gt; (*vertices.at(2)), xy);
<a name="l00610"></a>00610                 }
<a name="l00611"></a>00611                 <span class="keywordflow">else</span> {
<a name="l00612"></a>00612                     tempVec2 = linearInterpolation(const_cast &lt;AffectVertex&amp;&gt; (*vertices.at(1)), const_cast &lt;AffectVertex&amp;&gt; (*vertices.at(2)), xy);
<a name="l00613"></a>00613                 }
<a name="l00614"></a>00614             }
<a name="l00615"></a>00615             <span class="keywordflow">if</span> (a &lt;= max(co[2][1], co[3][1]) &amp;&amp; a &gt; min(co[2][1], co[3][1])) { <span class="comment">//</span>
<a name="l00616"></a>00616                 <span class="comment">//cout &lt;&lt; &quot;crossing line 2&quot; &lt;&lt; endl;</span>
<a name="l00617"></a>00617                 <span class="keywordflow">if</span> (tempVec1.empty()) {
<a name="l00618"></a>00618                     tempVec1 = linearInterpolation(const_cast &lt;AffectVertex&amp;&gt; (*vertices.at(2)), const_cast &lt;AffectVertex&amp;&gt; (*vertices.at(3)), xy);
<a name="l00619"></a>00619                 }
<a name="l00620"></a>00620                 <span class="keywordflow">else</span> {
<a name="l00621"></a>00621                     tempVec2 = linearInterpolation(const_cast &lt;AffectVertex&amp;&gt; (*vertices.at(2)), const_cast &lt;AffectVertex&amp;&gt; (*vertices.at(3)), xy);
<a name="l00622"></a>00622                 }
<a name="l00623"></a>00623             }
<a name="l00624"></a>00624             <span class="keywordflow">if</span> (a &lt;= max(co[3][1], co[0][1]) &amp;&amp; a &gt; min(co[3][1], co[0][1])) { <span class="comment">//</span>
<a name="l00625"></a>00625                 <span class="comment">//cout &lt;&lt; &quot;crossing line 3&quot; &lt;&lt; endl;</span>
<a name="l00626"></a>00626                 <span class="keywordflow">if</span> (tempVec1.empty()) {
<a name="l00627"></a>00627                     tempVec1 = linearInterpolation(const_cast &lt;AffectVertex&amp;&gt; (*vertices.at(3)), const_cast &lt;AffectVertex&amp;&gt; (*vertices.at(0)), xy);
<a name="l00628"></a>00628                 }
<a name="l00629"></a>00629                 <span class="keywordflow">else</span> {
<a name="l00630"></a>00630                     tempVec2 = linearInterpolation(const_cast &lt;AffectVertex&amp;&gt; (*vertices.at(3)), const_cast &lt;AffectVertex&amp;&gt; (*vertices.at(0)), xy);
<a name="l00631"></a>00631                 }
<a name="l00632"></a>00632             }
<a name="l00633"></a>00633             <span class="keywordflow">if</span> (tempVec1.empty() || tempVec2.empty()){
<a name="l00634"></a>00634                 <span class="comment">//cout &lt;&lt; &quot;AffectPolygon::getIntensity: ERROR one of the Vectors is empty!&quot; &lt;&lt; endl;</span>
<a name="l00635"></a>00635                 <span class="keywordflow">return</span> 0.0;
<a name="l00636"></a>00636             }
<a name="l00637"></a>00637             returnValue = tempVec1.at(0);
<a name="l00638"></a>00638             <span class="keywordflow">if</span> (tempVec1.at(1) != tempVec2.at(1)) {
<a name="l00639"></a>00639                 returnValue = (p - tempVec1.at(1)) / (tempVec2.at(1) - tempVec1.at(1))
<a name="l00640"></a>00640                         * (tempVec2.at(0) - tempVec1.at(0))
<a name="l00641"></a>00641                         + tempVec1.at(0);
<a name="l00642"></a>00642             }
<a name="l00643"></a>00643         }
<a name="l00644"></a>00644     }
<a name="l00645"></a>00645     <span class="comment">//cout &lt;&lt; &quot;AffectPolygon::getIntensity: returning &quot; &lt;&lt; returnValue &lt;&lt; endl;</span>
<a name="l00646"></a>00646     <span class="keywordflow">return</span> returnValue;
<a name="l00647"></a>00647 }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649 vector&lt;float&gt;
<a name="l00650"></a>00650 AffectPolygon::linearInterpolation(<a class="code" href="class_affect_vertex.html">AffectVertex</a> <span class="keyword">const</span> &amp;v1, <a class="code" href="class_affect_vertex.html">AffectVertex</a> <span class="keyword">const</span> &amp;v2, <span class="keywordtype">int</span> coord[])
<a name="l00651"></a>00651 {
<a name="l00652"></a>00652     vector&lt;float&gt; returnVector;
<a name="l00653"></a>00653     <span class="keywordtype">int</span> xy = 1;
<a name="l00654"></a>00654     <span class="keywordflow">if</span> (v1.coords[1] == v2.coords[1]) {
<a name="l00655"></a>00655         cout &lt;&lt; <span class="stringliteral">&quot;AffectPolygon::linearInterpolation: switching to x!&quot;</span> &lt;&lt; endl;
<a name="l00656"></a>00656         xy = 0;
<a name="l00657"></a>00657     }
<a name="l00658"></a>00658     <span class="keywordtype">int</span> yx = (xy + 1) % 2;
<a name="l00659"></a>00659     <span class="comment">//cout &lt;&lt; &quot;v2.intensity = &quot; &lt;&lt; v2.intensity &lt;&lt; &quot;, v1.intensity = &quot; &lt;&lt; v1.intensity</span>
<a name="l00660"></a>00660     <span class="comment">//     &lt;&lt; &quot;. coord[0] = &quot; &lt;&lt; coord[0] &lt;&lt; &quot;, coord[1] = &quot; &lt;&lt; coord[1] &lt;&lt; endl;</span>
<a name="l00661"></a>00661     <span class="keywordtype">float</span> factor = ((float)(coord[xy] - v1.coords[xy]) / (float)(v2.coords[xy] - v1.coords[xy]));
<a name="l00662"></a>00662     <span class="keywordtype">float</span> returnValue = (v2.intensity - v1.intensity)
<a name="l00663"></a>00663             * factor
<a name="l00664"></a>00664             + v1.intensity;
<a name="l00665"></a>00665     returnVector.push_back(returnValue);
<a name="l00666"></a>00666     <span class="comment">//cout &lt;&lt; (v2.intensity - v1.intensity) &lt;&lt; &quot; * &quot; &lt;&lt; factor &lt;&lt; &quot; + &quot; &lt;&lt; v1.intensity &lt;&lt; &quot; = &quot; &lt;&lt; returnValue &lt;&lt; endl;</span>
<a name="l00667"></a>00667     <span class="keywordtype">int</span> yx_coord = ((float)(coord[xy] - v1.coords[xy]) / (float)(v2.coords[xy] - v1.coords[xy])) * (<span class="keywordtype">float</span>)(v2.coords[yx] - v1.coords[yx]) + v1.coords[yx];
<a name="l00668"></a>00668     if (xy == 1){
<a name="l00669"></a>00669         <span class="comment">//cout &lt;&lt; &quot;AffectPolygon::linearInterpolation: returning &quot; &lt;&lt; returnValue &lt;&lt; &quot; at (&quot; &lt;&lt; yx_coord &lt;&lt; &quot;, &quot; &lt;&lt; coord[1] &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span>
<a name="l00670"></a>00670         returnVector.push_back((<span class="keywordtype">float</span>)yx_coord);
<a name="l00671"></a>00671         returnVector.push_back((<span class="keywordtype">float</span>)coord[1]);
<a name="l00672"></a>00672     }
<a name="l00673"></a>00673     <span class="keywordflow">else</span> {
<a name="l00674"></a>00674         <span class="comment">//cout &lt;&lt; &quot;AffectPolygon::linearInterpolation: returning &quot; &lt;&lt; returnValue &lt;&lt; &quot; at (&quot; &lt;&lt; coord[0] &lt;&lt; &quot;, &quot; &lt;&lt; yx_coord &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span>
<a name="l00675"></a>00675         returnVector.push_back((<span class="keywordtype">float</span>)coord[0]);
<a name="l00676"></a>00676         returnVector.push_back((<span class="keywordtype">float</span>)yx_coord);
<a name="l00677"></a>00677     }
<a name="l00678"></a>00678     <span class="keywordflow">return</span> returnVector;
<a name="l00679"></a>00679 }
</pre></div></div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 23 2011 13:44:08 for WASABIEngine by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
